<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // Angular,Ionic
        // React,React Native
        // Python,Django
        //
        //---------------------------------------------
        // Angular
        //
        // vue.js开发方式
        // 1.script 引入 vue.js
        // 2.脚手架方式
        // Angular v1.x 开发方式：1.script 引入 vue.js  2.脚手架方式
        // Angular v2.x 开发方式：1.脚手架方式
        //
        // 搭建 Angluar 开发环境
        //
        // 1.下载并安装脚手架工具
        // 默认仓库：registry.npmjs.com
        // npm install -g @angular/cli
        // 此步骤会下载全局工具 ng.cmd
        //
        // 修改npm默认的下载仓库地址为国内镜像网站
        // npm config set registry "..."
        // 例如，可以使用淘宝提供的npm镜像
        // npm config set registry https://registry.npm.taobao.org
        //
        // 2.运行脚手架工具创建空白项目
        // ng(.cmd) new "projectName"
        //
        // Would you like to add Angular routing? (y/N)
        //
        //
        //
        // 3.进入空白项目并运行开发服务器
        // cd "projectName"
        // npm strat            ng serve --open
        //
        // 4.客户端访问测试
        // http://localhost:4200/
        //
        //
        // Angular 项目启动过程分析：
        // 1.Angular.json:ng项目的配置文件
        // index: ./src/index.html      <app-root></app-root>
        // main: ./src/main.ts
        //
        //---------------------------------------------
        //
        // Model:模型，即数据，MVVM中第一个M
        // Module:模块，1.node.js 2.es6 (import,export)  3.angular
        // Modal:模态对话框
        //
        //---------------------------------------------
        //
        // 2.main.ts --> bootstrapModule(AppModule) -->
        //
        // 3.app.module.ts -->  bootstrap: [AppComponent]
        //
        // 4.app.component.ts --> selector: 'app-root',
        //                    --> templateUrl: './app.component.html', --> HTML片段
        //                    --> styleUrls: ['./app.component.css']   --> CSS片段
        //
        // ---------------------------------------------------------------------------------------------
        // --------------------------------------模块---------------------------------------------------
        // ---------------------------------------------------------------------------------------------
        //
        // 2.Angular 核心概念之一：模块
        // Module：不同于Node.js 或 ES6 中的模块，NG中的模块就是一个抽象的容器，用于对组件进行分组
        // 整个应用初始时有且只有一个主模块：AppModule
        //
         // ---------------------------------------------------------------------------------------------
        // --------------------------------------组件---------------------------------------------------
        // ---------------------------------------------------------------------------------------------
        // 3.Angular 核心概念之二：组件 ,   组件式编程可以提高代码可维护性
        // Component: 是一段可以反复使用的页面片段，如，页头、轮播、手风琴...
        // 组件(Component) = 模板(Template) + 脚本(Script) + 样式(Style)
        //                  View                Model
        //
        // 提示: NG中，任何一个组件都必须声明在一个模块中！
        //
        // 自定义组件的步骤
        // 1.创建组件class
        // @Component({
        //   //MetaData 元数据，描述数据的数据
        //  selector: 'myC01',
        // template: '<h2></h2>'
        //
        // })
        // export class myC01 { }
        //
        // 2.在某个模块中注册组件class
        //
        // 3.使用已经注册过的组件
        //
        //
        //
        // npx:Node Package Executor,第三方可执行文件的执行工具
        // npx可用于执行当前项目中 node_modules/.bin 目录下的可执行文件
        //
        // Angular 提供的创建组件的简化工具
        // ng generate component "componentName"
        // npx ng generate component "componentName"
        //
        // 可简化为
        //
        // ng g component "componentName"
        // npx ng g component "componentName"
        //
        // ---------------------------------------------------------------------------------------------
        // --------------------------------------数据绑定-------------------------------------------------
        // ---------------------------------------------------------------------------------------------
        //
        // 4.Angular 核心概念之三：数据绑定
        //
        // 1.HTML绑定:      {{NG Expression}}
        // 在 NG 表达式中可以执行哪些代码？
        // 算数运算? 可以
        // 比较运算? 可以
        // 逻辑运算? 可以
        // 三目运算? 可以
        // 调用函数? 可以
        // 创建对象? 不可以，NG表达式中禁止出现new关键字
        // JSON序列化? 不可以，NG表达式中JSON是undefined
        //
        //
        // 2.属性绑定： vue.js,v-bind 或简写为 ":"
        //
        // Angular中
        // 形式1: 直接在属性上用 {{}} <p titile = "{{..}}">
        // 形式2：使用[]做属性绑定 <p [title]="..">
        //
        // 注意：属性绑定通常赋值为变量，如果赋值为常量(如字符串常量) 必须用引号括起来,如 <img [src]="'../assets'+imgUrl">
        //
        // 3.事件绑定:      vue.js,v-on 或简写为 "@"
        //
        // Angular中
        // (click) = "add_()"
        // 注意：事件名用()括起来，处理函数名后必须与()
        //
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        // 4.指令绑定
        //
        // 指令：
        // 1.预定义指令:
        // 组件，是一种特殊的指令
        // 结构型指令，
        // 属性型指令
        //
        // 2.自定义指令
        // 步骤一：创建指令class
        // 步骤二：在模块中注册指令class
        // 步骤三：使用指令
        //
        // 简化命令：[npx] ng generate directive 'directiveName'
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        // Angular 中的指令系统
        //
        // vue中常用指令
        // v-on "()" , v-bind "[]" , v-for , v-if , v-else ,  v-show , v-hide , v-text/html ...
        //
        //---------------------------------
        //
        // 1.循环绑定
        // *ngFor
        // <ANY *ngFor="let temVarible of DATA; let i=index;">
        // <ANY *ngFor="let temVarible of DATA; index as i;">
        //
        // 2.选择绑定
        // *ngIf
        // <ANY *ngIf="bool exp">
        // 说明：如果布尔表达式为false，则当前元素从DOM数上删除
        //
        // <ANY *ngIf="bool exp; else elseBlock">...</ANY>
        // <ng-template #elseBlock> <ANY>...</ANY> </ng-template>
        //
        // 3.样式绑定
        //  ngStyle  ngClass
        //  [ngStyle]
        //  说明：ngStyle 绑定的值可以是一个对象！对象属性就是CSS样式名
        //  <ANY [ngStyle]="obj">
        //
        //
        //
        //  [ngClass]
        //  <ANY [ngClass]="obj">
        //  说明：ngClass 绑定的值可以是一个对象！对象属性就是CSS 的 class名，属性值为 true/false,true的话该class就出现；否则该class不出现
        //
        //
        //  特殊的选择绑定
        //  ngSwitch
        //  <ANY [ngSwitch]="switch_expression">
        //  <ANY *ngSwitchCase="match_expression_1"></ANY>
        //  <ANY *ngSwitchCase="match_expression_2"></ANY>
        //  ..
        //
        //  <ANY *ngSwitchDefault="match_expression_2"></ANY>
        // </ANY>
        // ---------------------------------
        //
        // ------------------------------------------------------------------------------------------------
        //
        //  Angular 中的预定义指令 分为三类
        // 1.组件指令：NG中Component 继承自 Directive
        // 2.结构型指令：会影响DOM数结构，必须使用 * 开头，如 *ngFor,*ngIf
        // 3.属性型指令: 不会影响DOM数结构，只是影响元素外观或行为，必须用[]括起来, 如 [ngClass],[ngStyle]
        //
        //
        // -------------------
        //
        // 5.双向数据绑定指令
        //
        // [(ngModel)]
        //
        // 前提：必须在当前模块中导入ngModel指令所在的模块
        //
        //
        //  方向1：Model ==> View, 模型变则视图变,属性绑定，把模型数据绑定到视图， 用 [] 绑定
        //
        //  方向2：View ==> Model, 视图(表单元素) 变 则模型变，用户的输入改变了当前输入框的值，触发值改变的事件，监听事件，修改模型，
        //  用 () 绑定
        //
        //  <input/select/textarea [(ngModel)]="uname">
        //  注意： ngModel 指令 不在 CommonModule 中，而在 FormModule中
        //  使用之前必须在主模块中导入该模块
        //
        //  --app.module.ts
        //  @NgModule({
        //   imports:[BrowserModule,FormModule,]
        //
        // })
        //
        //  如果想直接监视模型数据改变，可以绑定ngModelChange事件
        //
        //
        // --------------
        //
        // 如何自定义指令
        //
        // 提示：创建指令的简单工具 ng g directive "directiveName"
        //
        // 一个指令是作为标签的属性来用的，自定义的指令都是作为元素属性来使用的, selector 应该是: [directiveName]
        // <ANY needEm></ANY>
        //
        //
        // --------------
        //
        // ------------------------------------------------
        //
        // 代码可维护性
        //
        // HTML: 组件化编程
        // CSS: 使用预编译样式语言:sass/scss/stylus/less
        // JS: 面向对象，组件化编程
        //
        // -------------------------------------------------
        //
        // ------------------------------------------------
        //
        // Node.js/ES6模块      NG模块
        //
        // Node.js/ES6模块 的作用：防止全局污染
        //
        // NG模块：对项目中的大量组件/指令/管道/服务等对象进行分组
        //
        // -------------------------------------------------
        //
        // ------------------------------------------------------------------------------------------------
        // ---------------------------------------------管道------------------------------------------------
        // ------------------------------------------------------------------------------------------------
        //
        // Angular 核心概念之五：过滤器/管道
        //
        // Filter: 用于在View中呈现数据时显示为另一种格式;过滤器本质是一个函数: function(oldVal) {... return newVal}
        // 接收原始数据转换为新的格式进行输出
        //
        // 使用过滤器： {{e.salary | filterName}}
        // Angular 2.x 中，过滤器更名为 "管道(Pipe)"
        // 使用过滤器： {{e.salary | pipeName}}
        //
        // 自定义管道的格式
        // 1.创建管道class，实现转换功能
        //
        // @Pipe({name:'sex'})
        // export class SexPipe{ transform(val){..return..} }
        //
        //
        // 2.在模块中注册管道
        //
        // app.module.ts
        // declarations: [SexPipe]
        //
        //
        // 3.在模板 视图 中使用管道
        //
        // {{e.empSex | sex}}
        //
        // 简化命令: ng  g pite 'xxx'
        //
        // -------------------------------------------------
        //
        // Vue.js中没有预定义管道；Angular 提供了几个预定义管道
        //
        // 1.lowercase: 转换为小写
        // {{ename | lowercase}}
        // 2.uppercase: 转换为大写
        // {{ename | uppercase}}
        // 3.titlecase: 转换为首字母大写
        // {{ename | titlecase}}
        // 4.slice:只显示字符串的一部分
        // {{ename | slice:0:3}}
        // 5.json:把JS对象序列化为JSON字符串
        // {{obj | json}}
        // 6.number: 把数字转换为具有指定整数位和小数位的字符串
        // {{num | number}
        // {{num | number:'4.1-4'}
        // 7.currency: 把数字转换为货币格式字符串: 货币符号+三位一逗号+二位小数位
        // {{num | currency:'JPY'}
        // {{num | currency:'¥'}
        // 8.data: 把数字转换为日期字符串
        // {{num | date}}
        // {{num | date:'yyyy-MM-dd HH:mm:ss'}}
        //
        // -------------------------------------------------
        // ------------------------------------------------------------------------------------------------
        // ------------------------------------服务和依赖注入(DI)------------------------------------------------
        // ------------------------------------------------------------------------------------------------
        //
        // -------------------------------------------------
        // 创建对象的两种方式
        //
        // 1.手动创建式
        // let c2 = new Car()
        //
        // 2.依赖注入式
        // 无需自己new，只需要声明依赖;服务提供者就会创建被依赖的对象，注入给服务需要者
        //
        // -------------------------------------------------
        //
        // Angular 核心概念之六：服务和依赖注入(DI)
        //
        // Service: Angular 认为，组件是与用户交互的一种对象，其中的内容都应该与用户操作有关系的；
        // 而与用户操作无关的内容都应该剥离出去，放在 "服务对象" 中，为组件服务。例如，日志记录、计时统计、数据服务器的访问
        //
        //
        // 创建服务对象的步骤：
        // 1.创建服务对象并指定服务提供者
        //
        //方式一：创建的服务对象是 "单例" 的，不论多少个组价使用该服务，只创建一个实例
        // 该服务对象中的属性在被多于一个组件使用的时候会出现属性覆盖问题
        //
        // @Injectable({ providedIn: 'root' })
        // 跟模块级服务对象
        // export class LogService {  }
        //
        //方式二：等同于方式一
        //
        // app.module.ts
        // providers: [ LogService ]
        //
        //
        //
        //方式三：每个组件对应的服务对象都是新建出来的
        //
        // log.serrvice.ts
        // @Injectable()
        // export class LoginService {  }
        //
        // Xxx.component.ts
        // @Component({ ... ,
        //
        // providers: [ LogService ]，  // 组件级服务对象
        // })
        // export class XxxComponent { }
        //
        //
        //
        //
        // 2.在组件中声明依赖，服务提供者就会自动注入进来，组件直接使用服务对象
        //
        // export class XxxComponent {
        //      constructor(xxx:LogService) { //此处的xxx变量就会被注入为 LogService 实例 }
        //  }
        //
        // 简化工具: ng generate service 'serviceName'
        //
        // -------------------------------------------------
        //
        // 服务对象的作用范围
        //
        // 声明服务提供者的方式：
        // 1.在跟模块中提供服务对象, 在整个应用中服务对象是 单例 的
        // 2.在组件中提供服务对象， 在每个组件的实例 中 服务都有一个实例
        //
        // 注意：项目中 只要服务对象中有属性，只能用方式2；否则推荐使用方式1
        //
        //
        //
        //
        // -------------------------------------------------
        //
        //
        //
        //
        //
        // -------------------------------------------------
        //
        // 前端有哪些异步请求工具？各自的利弊
        //
        //  1.原生XHR
        // 本质： let xhr = new XMLHttpRequest();
        // 优势：浏览器支持的原生技术
        // 劣势：基于回调方式处理相应消息 (回调地狱)
        //
        //  2.jQuery.ajax()
        // 本质：也是XHR，只是进一步封装而已
        // 优势：比原生要简单
        // 劣势：基于回调方式处理相应消息 (回调地狱)
        //
        //  3.Axios
        // 本质：也是XHR，只是进一步封装而已
        // 比原生要简单
        // 基于Promise处理响应;可以排队、并发；
        //
        //
        //
        //  4.Angular HttpClient
        // 本质：也是XHR，只是进一步封装而已
        // 比原生要简单；
        // 基于 "观察者模式" 处理响应；可以排队、并发、撤销；
        //
        //  5.React Fetch
        // 本质：不再是XHR，是W3C提出的新技术
        // 比XHR从根本上就更先进；
        // 天然基于Promise；
        // 浏览器兼容性问题;
        //
        //
        // -------------------------------------------------
        //
        // 使用服务对象时(依赖注入)常见错误
        // NullInjectorError: R3InjectorError(AppModule)[LogService -> LogService -> LogService]:
        // NullInjectorError: No provider for LogService!
        // 指定的服务对象没有服务提供者
        //
        // 解决方案:
        // 1.保证创建服务对象时指定 providedIn: 'root'
        // 2.组件声明依赖时服务对象不能写错
        //
        //
        // -------------------------------------------------
        //
        // 使用Angular官方提供的服务对象 HttpClient Service
        //
        // HttpClient 服务对象，用于向指定的URL发起异步请求
        //
        // 使用步骤
        // 1.在主模块中导入 HttpClient 服务 所在的模块
        // app.module.ts
        // imports [BrowserModule, FormsModule, HttpClientModule]
        //
        // 2.在需要使用异步请求的组件中，声明依赖于 HttpClient 服务对象，就可以使用该对象发起异步请求了
        // httpCli: HttpClient;
        // ... { constructor (http:HttpClient) { this.httpCli = http } }
        //
        // 3.调用HttpClient实例实现异步请求
        // this.httpCli.get(url) 返回值 Observable
        // this.httpCli.get(url).subscribe((response)=>{})
        //
        //
        //
        //
        // -------------------------------------------------
        //
        // HttpClient 服务：是Angluar提供的用于发起异步XHR请求的对象
        //
        // -------------------------------------------------
        //
        // 观察者模式
        //
        // Observable：可被关注的对象，在未来某个不确定的时间点可能抛出特定的事件
        //
        // Subscribe：建立与可被关注的对象的通信协议，一旦得到新消息立即会被通知
        //
        //
        //
        //
        //
        //
        //
        //
        // -------------------------------------------------
        //
        //
        //
        // -------------------------------------------------
        //
        // TS使用步骤
        //
        // 1.下载ts编译器
        //  npm i -g typescript
        // 2.编写 .ts 文件，使用编译器转化为 .js
        //  tsc xxx.ts
        // 得到 xxx.js
        //
        // -------------------------------------------------
        //
        // TS的扩展特性
        //
        // 1.TS是强类型语言 --- JS是弱类型语言
        // 强类型语言特点：变量、形参、函数都要声明类型
        //
        // 2.TS对属性和方法成员定义三种访问修饰符:
        // private:私有成员只能在本类内部使用
        //
        // protected: 被保护的成员只能在本类内部及子类内部使用
        //
        // public: 公共成员可以在本类内部以及外部使用
        //
        // 提示：一般情况下，class内属性不应该让外界随便访问，通常设置为 private
        // 方法一般允许调用的，通常设置为public
        //
        // 3.访问修饰符的特殊用法
        //
        // 下述两种写法的作用相同
        //
        // class Xxx {
        //  private xx: number;
        //  constructor(xx_: number) { this.xx = xx_; };
        //
        // }
        //
        // class Xxx {
        //  constructor(private xx_: number) {};
        //
        // }
        //
        //
        //
        // 4.面向对象编程 class 和 interface
        //
        // interface: 接口,是一种特殊的类,"要求某个class必须具备xxx方法"    如管道类必需提供transform方法
        //
        // interface Runnable { start(); stop();  }     //接口中的方法没有主体！
        //
        // class Car implements Runnable {  start() {}; stop() {};}        //接口的实现者必须提供指定的方法，要有主体
        //
        //--------------------------------------------------
        //
        // 接口只定义行为 并不包含类别的含义 不指代具体的某类事物
        //
        // -------------------------------------------------
        //
        // 5.装饰器
        //
        //
        // -------------------------------------------------
        //
        //
        // ------------------------------------------------------------------------------------------------
        // ------------------------------------组件的生命周期钩子函数------------------------------------------------
        // ------------------------------------------------------------------------------------------------
        //
        // ------------------------------------------------------------------------------------------------
        //
        // 组件的生命周期钩子函数
        //
        // Angular 中组件的生命周期钩子函数调用顺序：
        //
        // (0) constructor() 组件对象被创建了
        // (1) ngOnChanges() 组件绑定的属性值发生改变
        // <xxx [title]='myTitle' ></xxx>
        //
        //
        // (2) ngOnInit() 组件初始化完毕，等同于Vue.js的mounted
        //
        // (3) ngDoCheck() 组件检查到了系统对自己的影响
        // (4) ngAfterContenInit() 组件的内容初始化完成
        // (5) ngAfterContentChecked() 组件的内容发生变化需要检查
        // <myc01> <p> {{uname}} </p> </myc01>  p发生改变
        //
        //
        // (6) ngAfterViewInit() 组件的视图初始化完成
        // (7) ngAfterViewChecked() 组件的视图发生变化需要检查
        // template: '<div> {{uname}} </div>'  div发生改变
        //
        //
        // (8) ngOnDestroy() 组件即将被从DOM树上卸载,适合执行一些资源释放性语句，
        // 例如：定时器销毁
        // *ngIg = 'false'
        // ngOnDestroy() xxx...
        //
        //
        //
        //
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        //
        // -------------------------------------------------
        //
        // Angular 模块中可以声明哪些种类的对象?
        // 组件、指令、管道、服务(providers)、其他模块(imports)、fn(全局) 、value(全局)
        //
        //
        //
        //
        // -------------------------------------------------
        //
        // ------------------------------------------------------------------------------------------------
        // ------------------------------------组件间的数据传递------------------------------------------------
        // ------------------------------------------------------------------------------------------------
        //
        //
        // 组件间的数据传递
        //
        // 父组件==>子组件
        //
        // 子组件==>父组件
        //
        // 兄弟间数据传递，兄弟==>父组件==>另一个兄弟
        //
        // -------------------------------------------------
        //
        // 1.父子间组件传递
        //  Vue.js 和 Angular 中父子间消息传递原理一样， "Props Down,Events Up"
        // 方向1：父 ==> 子
        // 父组件通过 "子组件的自定义属性" 向下传递数据给子组件
        //      父：
        //      1.blog-parent.component.ts,
        //          父组件创建数据
        //
        //          userName = '苍茫大地'
        //      2.blog-parent.component.html,
        //           父组件将自己的数据绑定给子组件的属性
        //
        //      <app-blog-child-photo [child2Name]="userName" > </app-blog-child-photo>
        //
        //      子：
        //      3.blog-child-photo.component.ts，
        //          子组件定义扩展属性
        //
        //          @Input()    //声明为输入型属性
        //          child2Name='';
        //
        //      4.blog-child-photo.component.html
        //          子组件使用自定义属性
        //
        //          <xxx> {{child2Name}} </xxx>
        //
        //
        // ---------------------
        //
        // 方向2：子 ==> 父
        // 子组件通过触发特定的事件(其中携带着数据)，把数据传递给父组件(父组件提供事件处理方法)
        //
        //
        //      子：
        //      1.blog-child-modify.component.ts,
        //      自定义事件发射器----输出型属性
        //
        //       @Output
        //       changeEvent = new EventEmitter()
        //
        //      2.blog-child-modify.component.ts,
        //          在某个时刻发射事件,
        //
        //          this.changeEvent.emit('子组件想传给父组件的数据')
        //
        //
        //      父：
        //      3.blog-parent.component.html
        //          监听子组件的事件,
        //
        //          <app-blog-child-modify (changeEvent)="changeHandler($event)"></app-blog-child-modify>
        //
        //
        //      4.blog-parent.component.ts
        //          接收子组件传递的数据,
        //
        //          changeHandler(event: Event) { event就是子组件传递过来的数据 }
        //
        //
        // ---------------------
        //
        // 组件的模板中可以出现的内容
        // 1.HTML标准元素
        // 2.组件对应的元素
        // 3.Angular 指令
        // 4.模型数据(或方法) (Model)
        // 5.事件对象(或子组件传递的数据) --- $event
        // 6.模板变量
        // 7.NG元素识别符
        //
        //
        // 6. <li *ngFor="let item of xxx" > {{item}} </li>
        // 7.<div #myDiv ></div>
        //
        // ---------------------
        //
        // 父子组件传递数据的简便方法：
        //
        // 父组件直接使用子组件对象的引用-----视图子组件
        //
        // 对象的识别符
        // @ViewChild
        //
        // blog-parent.component.html:
        // 使用#为子组件声明识别符               //In the template, you use the hash symbol, #, to declare a template variable.
        // <div #c1> </div>     <myc02 #c2></myc02>         //template variables
        //
        // blog-parent.component.ts:
        // @ViewChild('c1',{static: true})
        // child1:any;
        // @ViewChild('c2',{static: true})
        // child2:any;
        //
        // 提示：ViewChild 装饰器用于将子组件 识别符与某个属性关联起来，第一个参数必须是已经存在的子组件识别符(不带#)，
        // 第二个参数 static 指定该组件是否为 "静态组件" (不会动态变化的组件，如带有 *ngIf="xx" *ngFor="..")
        //
        // 注意：通过 "ViewChild--视图子组件" 方式，父组件可以获得任一子组件中的任意数据
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        // ------------------------------------------------------------------------------------------------
        // ------------------------------------路由和导航------------------------------------------------
        // ------------------------------------------------------------------------------------------------
        //
        // Angular核心概念七：路由和导航
        //
        //
        // ---------------------
        //
        // 多页面应用：一个项目中有多个完整HTML文件，可以使用超链接跳转---(销毁一颗DOM树，"同步" 请求另一颗,得到之后再重建新的DOM树)
        // 不足：DOM树要反复重建，间隔中客户端一片空白
        //
        // 单页面应用：SPA(Single Page Application) ， 整个项目中有且只有一个 <完整的> HTML 文件，
        // 其他的 <页面> 都只是 div片段；需要哪个 <页面> 就将其 "异步" 请求下来，插入到 <完整的> HTML文件中
        //
        // 单页应用的优势：整个项目中客户端只需要下载一个HTML页面，创建一个完整的DOM树，页面跳转 都是 一个div替换另一个 div 而已
        // 能够实现过场动画
        //
        //
        // ---------------------
        // -------------------
        //
        // route: 路由，有两部分：目标地址(路由地址) + 处理过程(路由方法/组件)
        // router: 路由器，内部包含着路由词典
        //
        // -------------------
        //
        //
        // Angular 中使用 "单页应用" 的步骤：
        //
        // 0. 创建整个应用需要的路由组件
        //
        // ng g component index
        // ng g component productList
        // ng g component productDetail
        // ng g component userCenter
        //
        //
        // 1.定义 "路由词典"  [{PATH--Component},{PATH--Component},..]
        //      app.module.ts, 为每个路由组件分配一个路由地址
        //      let routes = [
        //      { path:'index', component:IndexComponent},
        //      ................
        //      { path:'uCenter',component:UCenterComponent},
        //
        // ]
        //
        //
        //
        // 2.注册 "路由词典"
        //      app.module.ts,
        //      imports [ xxx, RouterModule.forRoot(routes) ],
        //
        //
        //
        // 3.创建路由组件挂载点(称为 "路由出口")
        //      app.component.html,
        //      <router-outlet></router-outlet>
        //
        //
        //
        // 4.访问测试
        //      http://localhost:4200/index
        //      ..
        //      http://localhost:4200/uCenter
        //
        //
        // 注意：
        // 1.路由词典中的路由地址 不能以 / 开头或结尾，但中间可以包含 /
        // 2.路由词典中可以指定一个默认首页地址, {path:"", component:"xxx"}
        // 3.路由词典中每个路由中要么指定 component (由哪个组件提供能容) , 要么指定 redirectTo (重定向到另一个路由地址)
        // 4.路由词典中可以指定一个匹配任意地址的地址： "**"，注意该地址只能用于整个路由词典的最后一个！！
        //
        //
        //
        // -------------------
        //
        // 路由跳转(导航): 从一个路由地址跳转到另一个
        //
        //      实现方案：
        //
        //      方式一：使用模板方法
        //
        //           <ANY routerLink="/PATH">XXX</ANY>
        //       注意： 1.可用于任意标签上
        //             2.跳转地址应该以 / 开头，防止以相对方式跳转
        //
        //
        //      方式二：使用脚本方法
        //
        //       注意: Router类 是 RouterModule 提供的一个服务类，声明依赖即可使用
        //
        //       constructor(private router:Router) {}       //声明依赖
        //       ....
        //       xxX() { this.router.navigateByUrl('/PATH') }        //执行跳转
        //
        //
        // -------------------
        //
        // Vue.js 中的路由跳转的机制有哪些
        //
        // 1.hash法:只需要修改url中的 hash 部分
        // http://localhost/index.html#/xx
        // 浏览器的后退按钮
        //
        // 2.history法：需要修改 window.history 对象，从而支持浏览器自带的后退按钮
        // http://localhost/xx
        //
        // -------------------
        //
        // -------------------
        //
        // Angular 中的路由跳转的机制有哪些
        //
        // 1.history法：需要修改 window.history 对象，从而支持浏览器自带的后退按钮
        // http://localhost/xx
        //
        // -------------------
        //
        // 路由参数
        //
        //      在路由词典中定义路由地址时，其中可以包含可变的参数:
        //     { path: 'pDetail/:id', component: RouteProductDetailComponent },
        //    :id 是路由参数的标记
        //
        //    在路由跳转时可以为路由参数提供具体的参数值
        //    <a routerLink="/pDetail/5">查看商品5的详情</a>
        //    <a [routerLink]="['/pDetail','21']">查看商品21的详情</a>
        //
        //    到了目标路由组件，可以读取 "当前路由地址" 中的路由参数:
        //     constructor(private route:ActivatedRoute) {}
        //
        //      ngOnInit() {
        //     //读取路由参数
        //     this.route.params.subscribe((data)=>{ data['id']  就是路由参数  })
        // }
        //
        //
        //
        // -------------------
        //
        // 路由嵌套
        //
        //  一级路由：
        //  index: 首页
        //  user/center: 用户中心
        //
        // 二级路由：
        // user/center/info     用户中心>我的信息
        // user/center/avartar  用户中心>更改头像
        // user/center/security 用户中心>安全管理
        //
        //
        // 路由嵌套 修改路由词典：
        //
        //  const routes: Routes = [
        //  { path: '', component: RoutePrIndexComponent },
        //  { path: 'index', component: RoutePrIndexComponent },
        //  {
        //   path: 'user/center', component: RoutePrUserCenterComponent, children: [
        //          { path: 'info', component:InfoComponent},
        //          { path: 'avatar', component: AvatarComponent },
        //          { path: 'security', component: SecurityComponent },
        //       ]
        //   },
        //   { path: '**', component: RoutePrNotFoundComponent },
        // ];
        //
        //  注意： "用户中心" 下的二级路由组件挂载点/路由出口应该放在 UserCenter.component.html 中
        //
        //
        // -------------------
        //
        // 路由守卫
        //
        // 商业项目中，有些路由地址只能在特定条件下才能访问，
        // 例如： 用户中心，只能在登录后访问(会话限制)；
        // TMOOC 视频播放，只能在学校内播放(客户端IP地址限制)；
        // VIP学员视频播放，只能在 13:00 ~ 22:00  时间内播放(时间限制);
        // 商城后台所有页面，只能登录为管理员之后才能使用(权限限制)；
        // ....
        //
        //
        // Angular 提供了 "路由守卫(Guard)" 来实现访问路由组件前的检查功能：
        // 如果检查通过(return true) 就放行；如果检查不通过(return false) 就阻止访问
        //
        // 使用路由守卫的步骤：
        // 1.创建路由守卫class 可以使用 ng g guard guardNAME
        //
        // @Injectable({providedIn: 'root'})
        // export class LoginGuard {
        //      canActivate() {
        //          .. return true;
        //          .. return false;
        //      }
        // }
        //
        // 2.在路由词典中使用路由守卫
        //
        //  {path: '..',component: .., canActivate: [LoginGuard],..}
        //
        //
        //
        //
        // -------------------
        //
        // 练习：创建路由守卫 TimeGuard,检测当前的系统时间，如果在6点~23点之间允许访问，否则不允许；把此守卫应用于 "应用中心"组件
        //
        //
        // -------------------
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        // -------------------
        // 表单
        // 1.响应式表单
        // 2.模板驱动表单(基于模板语法, [(ngModel)] )
        //
        //
        // -------------------
        // 响应式表单
        //
        // 响应式表单的说明
        // 优势：让开发人员完全掌控表单
        // 表单数据的初始化
        // 表单值的获取
        // 表单验证和提交
        //
        //
        // -------------------
        // 响应式表单优势
        //  它提供了一种模型驱动的方式来处理表单输入
        //  简单理解：数据驱动视图的思想
        //  同步的数据访问，保证数据和视图是一致的、可预测的
        //  增强了可测试性，让测试变得更简单
        //  内置表单验证器，可以自定义验证器
        //  ....
        //
        //
        // -------------------
        //
        //  表单验证
        //
        //  表单验证的两种方式
        //  1.内置表单验证器:validators
        //  2.自定义
        //
        //
        //
        // -------------------
        //
        //  表单验证常用属性
        //
        //  value:表示该表单控件的值
        //  errors:表示描述错误的对象
        //  dirty:表示是否编辑过的表单
        //  hasError():用来获取错误信息
        //
        //
        // -------------------
        //  自定义验证器是个函数
        //  参数类型：AbstractControl
        //  验证成功：返回null
        //  验证失败“返回一个描述错误的对象(自定义)
        //
        //
        // -------------------
        // 
        // formGroup
        // 
        // 
        // 
        // -------------------
        // 
        // formBuilder
        // 
        // -------------------
        //
        //
        //
        //
        //
        //
        //
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        // 创建移动APP 可用的技术
        //
        //  技术名称        典型代表                            优势                                        劣势
        //
        //  原生开发        Android: Java 或 Kotlin         运行速度快、功能丰富                        两种设备互不兼容，开发速度慢
        //                 ios: Objective-C 或 Swift
        //
        //  WebView开发     Vue.js + Mint-UI                开发速度快                                  允许速度慢、功能有限
        //  HTML5/CSS/JS
        //
        //  混编开发        Angular + Ionic                 开发速度快、功能丰富                        允许速度慢
        //  H5+原生         Phonegap/Cordova
        //
        //  JS Bridge       React + ReactNative            开发速度快，运行速度快、功能丰富             两种平台下原生组件效果不一致
        //  编码是JS，
        //  运行的是原生代码
        //
        //  GPU 绘图        Google Flutter/ Dart            运行速度快、功能丰富、两种平台下的效果完全一样      目前还有不足(例如：绘图库代码过大)
        //
        //
        //
        //
        // ------------------------------------------------------------------------------------------------
        //
        // Angular UI 组件库 Ionic
        //
        // 官网：https://ionicframework.com/
        //
        // 概述:是一个移动端UI组件库，可以与Angluar/Vue/React 组合应用，也可以单独使用(script 直接引入)
        //
        // 使用Ionic的步骤：
        // 1.下载并安装全局的脚手架工具
        // npm i -g ionic      (NEW) npm install -g @ionic/cli
        //
        // 2.运行脚手架工具，创建一个空白项目
        // ionic start projNAME
        // ionic start projNAME blank/tabs/sidemenu
        //
        // 3.进入空白项目，启动开发服务器
        //
        // 4.使用客户端访问测试
        //
        //
        //-----------------------------------
        //
        // Ionic 的九种主题色:
        //
        // primary:蓝+白色
        // secondary:青+白色
        // tertiary:紫+白色
        // success:绿+白
        // warning:黄+白色
        // danger:红+白色
        // dark:黑+白
        // medium: 灰+白色
        // light: 白+黑色
        //
        //
        //
        //
        //
        //
        //-----------------------------------
        // Ionic 组件在ios和Android 的效果不一样
        // ios 风格:
        // md 风格: Meterial Design
        //
        // 二者，标题栏不同、按钮、图片显示效果、弹出框不同...
        //
        //-----------------------------------
        //
        // Ionic 移动App页面结构:
        // <ion-app>        保证始终铺满全屏的容器
        //  <ion-header>
        //      <ion-toolbar>
        //          <ion-title></ion-title>
        //      </ion-toolbar>
        //  </ion-header>
        //  </ion-content>
        //
        //  </ion-content>
        //  <ion-footer>
        //      <ion-toolbar>
        //          <ion-title></ion-title>
        //      </ion-toolbar>
        // </ion-footer>
        //
        // </ion-app>
        //
        //
        //-----------------------------------
        //
        // Ionic 中的响应式网格布局系统
        //
        // <ion-grid>
        //  <ion-row>
        //      <ion-col></ion-col>
        //  </ion-row>
        // </ion-grid>
        //
        //  这套布局系统的特点：
        //  1.列可以不指定宽度占比，可以在一行中多个列的宽度会平均分配，一行中列的数量取决于屏幕宽度
        //  2.可以使用size属性指定一列的宽度占比，总分为12；6就是 6/12,4 就是 4/12
        //  3.可以使用offset属性指定一列向右偏移指定的宽度，底层是用 margin-left 实现的，故会影响当前列及后续的列
        //  4.可以使用 push(向右推) pull(向左拉) 属性调整一列的出现位置，底层是用 绝对定位实现的，故不会影响同一行的其他列
        //
        //
        //
        //-----------------------------------
        //
        // Ionic 中常用的UI组件
        //
        // 1.Badge
        // <ion-badge color="九种主题色之一" ></ion-badge>
        // 2.Icon
        // 查找下列图标 首页、配置、购物车、用户、星星、心形、定位、邮件、拍照、扫码、后退、前进、刷新
        // 首页     <ion-icon name="home"></ion-icon>
        // 配置     <ion-icon name="settings"></ion-icon>
        // 购物车   <ion-icon name="cart"></ion-icon>
        // ..
        //
        //
        //
        //
        //
        //-----------------------------------
        //
        // Ionic常用组件--按钮
        //
        // <ion-buttom color="主题色" size="small/large" expand="block/full" shape="round" >
        // <ion-icon slot="start/end/icon-only"></ion-icon>
        // </ion-button>
        //
        //
        //-----------------------------------
        //
        // Ionic常用组件--输入框(ion-input)
        //
        // 最简单的没有边框的输入框
        // <ion-input type="" placeholder=""></ion-input>
        //
        // 带下边框和标签文字的输入框
        //
        // <ion-item>
        //  <ion-input label="username:" labelPlacement="fixed"></ion-input>
        // </ion-item>
        //
        // <ion-item>
        //  <ion-input label="username:" labelPlacement="stacked"></ion-input>
        // </ion-item>
        //
        // <ion-item>
        //  <ion-input label="username:" labelPlacement="floating" [(ngModel)]="userInput" ></ion-input>
        // </ion-item>
        //
        //-----------------------------------
        //
        // Ionic常用组件--搜索框(ion-searchbar)
        // <ion-searchbar placeholder-"" showCancelButton="always/never/focus" (ngModelChange)="change()" ></ion-searchbar>
        //
        //-----------------------------------
        //
        //-----------------------------------
        //
        // Ionic常用组件--卡片(ion-card)
        // <ion-card>
        //   <img alt="Silhouette of mountains" src="../assets/2.jpg" />
        //   <ion-card-header>
        //     <ion-card-title>TITLE</ion-card-title>
        //     <ion-card-subtitle>SUBTITLE</ion-card-subtitle>
        //   </ion-card-header>
        //   <ion-card-content>
        //     Lorem ipsum dolor sit amet consectetur adipisicing elit. Quae temporibus odio optio sit harum repellat qui, nemo
        //     suscipit incidunt nihil sunt minus error blanditiis autem maiores officiis exercitationem, consequuntur eveniet?
        //   </ion-card-content>
        // </ion-card>
        //
        //-----------------------------------
        //  Ionic常用组件--轮播广告(现改为swiper)
        //  https://ionicframework.com/docs/angular/slides#getting-started
        //
        //  ngOnInit() { this.swiperRef!.nativeElement.swiper.autoplay.start() }
        //
        //-----------------------------------
        //
        // Ionic常用组件--列表项(ion-item)
        // 提示：只要见到了 "有下划线的组件"，就想到列表项
        //
        //
        //    <ion-item detail="true" href="#" color="..">
        //         <ion-avatar/thumbnail slot="start">
        //             <img src="../assets/2.jpg" alt="">
        //         </ion-avatar/thumbnail>
        //         <ion-label>
        //              text
        //         </ion-label>
        //         <ion-button slot="end">
        //              text/icons
        //         </ion-button>
        //    </ion-item>
        //
        //
        //
        //
        //-----------------------------------
        // Ionic常用组件--列表(ion-list)
        // <ion-list>    <ion-item></ion-item>   </ion-list>
        //
        //
        //
        //-----------------------------------
        //
        // Ionic常用组件--无限滚动(ion-infinite-scroll)
        // 原理：在滚动条滚动到距离底部指定的 "临界值(threshold)" 时，立即触发特定的事件(ionInfinite) ('用户马上就要看到底部了，请加载更多数据')
        // 并显示出底部的 "加载中" 提示符号和文字。等到新的数据加载完成(complete)了，再次隐藏 "加载中" 提示信息，等待用户继续滚动。
        //
        //
        //     <ion-infinite-scroll #infiniteScroll threshold="30px" (ionInfinite) = "onIonInfinite($event)" >
        //             <ion-infinite-scroll-content loadingText="Please wait..." loadingSpinner="bubbles"></ion-infinite-scroll-content>
        //     </ion - infinite - scroll >
        //
        //
        //  onIonInfinite(e: any) {
        //     // ....异步加载更多数据....
        //  // complete
        //  e.target.complete()
        // }
        //
        //
        //
        //-----------------------------------
        //
        // Ionic常用组件--弹出式窗口 (ion-infinite-action-sheet/Alert/Modal)
        //
        //  官方推荐 Inline Alerts/Modals/ActionSheets
        //
        //  还可以通过 Controller 动态创建出来
        //
        //  constructor(private alertController: AlertController)
        //
        //
        // async presentAlert() {
        //         const alert = await this.alertController.create({
        //             header: 'Alert',
        //             subHeader: 'Important message',
        //             message: 'This is an alert!',
        //             buttons: ['btn1','btn2','..'],
        //         }).then((alertThen) => {
        //             alertThen.present(); //呈现异步创建出来的对话框
        //         });
        //
        //         // await alert.present();
        //
        //     }
        //
        //
        //
        //-----------------------------------
        //
        //                       Angular路由系统                                                    Ionic路由系统
        //
        // 1.创建路由词典       app.modules.ts                                                  the same as angular
        //                     const routes =[{path: '',component:...}];
        //
        //
        // 2.注册路由词典       app.module.ts                                                   the same as angular
        //                      imports:[BrowserModule,RouterModule.forRoot(routes)]
        //
        //
        // 3.路由出口        <router-outlet></router-outlet>                                 <ion-router-outlet></ion-router-out>
        //                                                                                   <ion-nav></ion-nav>
        //
        //
        //-----------------------------------
        //
        // Ionic常用组件--标签页式导航(ion-tabs)
        // 提示：标签页式导航组件必须与 "路由系统" 组合使用，使用步骤：
        // 1.创建路由词典
        // app.module.ts
        // const routes = [ { path: 'homePage', component: HomePageComponent }, ]
        //
        // 2.注册路由词典
        // app.module.ts
        // imports:[..,RouterModule.forRoot(routes),]
        //
        // 3.声明路由出口
        // app.component.html
        //
        // <ion-app>
        //  <ion-router-outlet></ion-router-outlet>
        //  <app-main></app-main>
        // </ion-app>
        //
        //
        // 4.创建标签页式组件
        // main.component.html
        // </ion-tabs>
        //  <ion-tab-bar slot="bottom">
        //      <ion-tab-button tab="homePage">
        //         <ion-icon name="home"></ion-icon>
        //         首页
        //     </ion-tab-button>
        //  </ion-tab-bar>
        //
        // </ion-tabs>
        //
        //
        // 5.访问测试
        // localhost:4200/homePage
        //
        //
        // (Ionic 7+ <ion-router-outlet></ion-router-outlet> 内嵌到 <ion-tabs></ion-tabs> 中 )
        //
        //-----------------------------------
        //
        // Angular 和 Ionic 的路由跳转
        //
        // Angular的路由跳转：
        //
        // constructor(private router:Router) {}
        // ....
        // this.router.navigateByUrl('/productList');
        //
        // Ionic 的路由跳转
        // constructor(private nav:NavController) {}
        // ....
        // this.nav('/productList');
        //
        //
        //-----------------------------------
        //
        // ------------------------------------------------------------------------------------------------
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //
        // 

    </script>
</body>

</html>